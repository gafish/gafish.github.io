<!DOCTYPE html>
<html lang='zh' ><meta charset="utf-8">
<meta name="viewport" content="width=device-width">


<title>《React 学习手册》2017版读书笔记 | gafish&#39;s Blog</title>

<meta name="generator" content="Hugo Eureka 0.8.4" />
<link rel="stylesheet" href="/css/eureka.min.css">
<script defer src="/js/eureka.min.js"></script>

<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link rel="preload"
  href="https://fonts.googleapis.com/css2?family=Lora:wght@400;600;700&family=Noto+Serif+SC:wght@400;600;700&display=swap"
  as="style" onload="this.onload=null;this.rel='stylesheet'">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@10.1.0/build/styles/solarized-light.min.css"
   media="print"
  onload="this.media='all';this.onload=null" crossorigin>
<script defer src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@10.1.0/build/highlight.min.js"
   crossorigin></script>

  <script defer src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@10.1.0/build/languages/dart.min.js"
     crossorigin></script>

<script defer src="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.14.0/js/all.min.js"
   integrity="sha256-uNYoXefWRqv&#43;PsIF/OflNmwtKM4lStn9yrz2gVl6ymo="  crossorigin></script>




<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css"
   integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3&#43;Aro6EYUG4&#43;cU&#43;KJWu/X"  media="print"
  onload="this.media='all';this.onload=null" crossorigin>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.js" 
  integrity="sha384-g7c&#43;Jr9ZivxKLnZTDUhnkOnsh30B4H0rpLUpJ4jAIKs4fnJI&#43;sEnkvrMWph2EDg4"  crossorigin></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/contrib/auto-render.min.js"
   integrity="sha384-mll67QQFJfxn0IYznZYonOWZ644AWYC&#43;Pt2cHqMaRhXVrursRwvLnLaebdGIlYNa"  crossorigin></script>
<script>
  document.addEventListener("DOMContentLoaded", function () {
    renderMathInElement(document.body, {
      delimiters: [
        { left: "$$", right: "$$", display: true },
        { left: "$", right: "$", display: false },
        { left: "\\(", right: "\\)", display: false },
        { left: "\\[", right: "\\]", display: true }
      ],
    });
  });
</script>


<script defer src="https://cdn.jsdelivr.net/npm/mermaid@8.9.2/dist/mermaid.min.js" 
  integrity="sha256-Zmpaaj&#43;GXFsPF5WdPArSrnW3b30dovldeKsW00xBVwE="  crossorigin></script>
<link rel="preconnect" href="https://www.google-analytics.com" crossorigin>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-102953279-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag() { dataLayer.push(arguments); }
  gtag('js', new Date());
  gtag('config', 'UA-102953279-1');
</script>


<link rel="icon" type="image/png" sizes="32x32" href="/images/avatar_hu1cbc6e5b6e4d3d49e9f6e4cb094fdd9c_51187_32x32_fill_box_center_3.png">
<link rel="apple-touch-icon" sizes="180x180" href="/images/avatar_hu1cbc6e5b6e4d3d49e9f6e4cb094fdd9c_51187_180x180_fill_box_center_3.png">

<meta name="description"
  content="Javascript 函数式编程 命令式与声明式 命令式编程的特点是，其代码重点关注的是达成目标的具体过程。 var string = &#39;hello world&#39;; var urlFriendly = &#39;&#39;; for (var i = 0; i &lt; string.length; i&#43;&#43;) { if (string[i] === &#39;&#39;) { urlFriendly &#43;= &#39;-&#39;; } else { urlFriendly &#43;= string[i]">
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [{
      "@type": "ListItem",
      "position": 1 ,
      "name":"文章",
      "item":"/posts/"},{
      "@type": "ListItem",
      "position": 2 ,
      "name":"《React 学习手册》2017版读书笔记",
      "item":"/posts/2021/12/18/react-learning-reading-notes/"}]
}
</script>



<script type="application/ld+json">
{
    "@context": "https://schema.org",
    "@type": "Article",
    "mainEntityOfPage": {
        "@type": "WebPage",
        "@id": "/posts/2021/12/18/react-learning-reading-notes/"
    },
    "headline": "《React 学习手册》2017版读书笔记 | gafish\u0027s Blog","datePublished": "2021-12-18T22:52:51+08:00",
    "dateModified": "2021-12-18T22:52:51+08:00",
    "wordCount":  4130 ,
    "publisher": {
        "@type": "Person",
        "name": "gafish",
        "logo": {
            "@type": "ImageObject",
            "url": "/images/avatar.png"
        }
        },
    "description": "Javascript 函数式编程 命令式与声明式 命令式编程的特点是，其代码重点关注的是达成目标的具体过程。 var string = \u0027hello world\u0027; var urlFriendly = \u0027\u0027; for (var i = 0; i \u0026lt; string.length; i\u002b\u002b) { if (string[i] === \u0027\u0027) { urlFriendly \u002b= \u0027-\u0027; } else { urlFriendly \u002b= string[i]"
}
</script><meta property="og:title" content="《React 学习手册》2017版读书笔记 | gafish&#39;s Blog" />
<meta property="og:type" content="article" />


<meta property="og:image" content="/images/avatar.png">


<meta property="og:url" content="/posts/2021/12/18/react-learning-reading-notes/" />




<meta property="og:description" content="Javascript 函数式编程 命令式与声明式 命令式编程的特点是，其代码重点关注的是达成目标的具体过程。 var string = &#39;hello world&#39;; var urlFriendly = &#39;&#39;; for (var i = 0; i &lt; string.length; i&#43;&#43;) { if (string[i] === &#39;&#39;) { urlFriendly &#43;= &#39;-&#39;; } else { urlFriendly &#43;= string[i]" />




<meta property="og:locale" content="zh" />




<meta property="og:site_name" content="gafish&#39;s Blog" />






<meta property="article:published_time" content="2021-12-18T22:52:51&#43;08:00" />


<meta property="article:modified_time" content="2021-12-18T22:52:51&#43;08:00" />



<meta property="article:section" content="posts" />




<body class="flex flex-col min-h-screen">
  <header class="fixed flex items-center w-full min-h-16 pl-scrollbar z-50 bg-secondary-bg shadow-sm">
    <div class="w-full max-w-screen-xl mx-auto"><script>
    let storageColorScheme = localStorage.getItem("lightDarkMode")
    if (((storageColorScheme == 'Auto' || storageColorScheme == null) && window.matchMedia("(prefers-color-scheme: dark)").matches) || storageColorScheme == "Dark") {
        document.getElementsByTagName('html')[0].classList.add('dark')
    }
</script>
<nav class="flex items-center justify-between flex-wrap px-4 py-4 md:py-0">
    <a href="/" class="mr-6 text-primary-text text-xl font-bold">gafish&#39;s Blog</a>
    <button id="navbar-btn" class="md:hidden flex items-center px-3 py-2" aria-label="Open Navbar">
        <i class="fas fa-bars"></i>
    </button>

    <div id="target"
        class="hidden block md:flex md:flex-grow md:justify-between md:items-center w-full md:w-auto text-primary-text z-20">
        <div class="md:flex md:h-16 text-sm md:flex-grow pb-4 md:pb-0 border-b md:border-b-0">
            <a href="/categories/%E6%8A%80%E6%9C%AF/" class="block mt-4 md:inline-block md:mt-0 md:h-(16-4px) md:leading-(16-4px) box-border md:border-t-2 md:border-b-2  border-transparent  mr-4">技术</a>
            <a href="/categories/%E7%94%9F%E6%B4%BB/" class="block mt-4 md:inline-block md:mt-0 md:h-(16-4px) md:leading-(16-4px) box-border md:border-t-2 md:border-b-2  border-transparent  mr-4">生活</a>
        </div>

        <div class="flex md:items-center">
            <div class="md:flex md:h-16 text-sm md:flex-grow pb-4 md:pb-0 border-b md:border-b-0">
                <a href="/tools/" class="block mt-4 md:inline-block md:mt-0 md:h-(16-4px) md:leading-(16-4px) box-border md:border-t-2 md:border-b-2 border-transparent mr-4">工具</a>
            </div>
            <div class="relative pt-4 md:pt-0">
                <div class="cursor-pointer hover:text-eureka" id="lightDarkMode">
                    <i class="fas fa-adjust"></i>
                </div>
                <div class="fixed hidden inset-0 opacity-0 h-full w-full cursor-default z-30" id="is-open">
                </div>
                <div class="absolute flex flex-col left-0 md:left-auto right-auto md:right-0 hidden bg-secondary-bg w-48 rounded py-2 border border-tertiary-bg cursor-pointer z-40"
                    id='lightDarkOptions'>
                    <span class="px-4 py-1 hover:text-eureka" name="Light">浅色</span>
                    <span class="px-4 py-1 hover:text-eureka" name="Dark">深色</span>
                    <span class="px-4 py-1 hover:text-eureka" name="Auto">自动</span>
                </div>
            </div>
        </div>
    </div>

    <div class="fixed hidden inset-0 opacity-0 h-full w-full cursor-default z-0" id="is-open-mobile">
    </div>

</nav>
<script>
    
    let element = document.getElementById('lightDarkMode')
    if (storageColorScheme == null || storageColorScheme == 'Auto') {
        document.addEventListener('DOMContentLoaded', () => {
            window.matchMedia("(prefers-color-scheme: dark)").addEventListener('change', switchDarkMode)
        })
    } else if (storageColorScheme == "Light") {
        element.firstElementChild.classList.remove('fa-adjust')
        element.firstElementChild.setAttribute("data-icon", 'sun')
        element.firstElementChild.classList.add('fa-sun')
    } else if (storageColorScheme == "Dark") {
        element.firstElementChild.classList.remove('fa-adjust')
        element.firstElementChild.setAttribute("data-icon", 'moon')
        element.firstElementChild.classList.add('fa-moon')
    }

    document.addEventListener('DOMContentLoaded', () => {
        getcolorscheme();
        switchBurger();
    });
</script>
</div>
  </header>
  <main class="flex-grow pt-16">
    <div class="pl-scrollbar">
      <div class="w-full max-w-screen-xl lg:px-4 xl:px-8 mx-auto">


<div class="grid grid-cols-2 lg:grid-cols-8 gap-4 lg:pt-12">
    <div
        class="col-span-2  lg:col-span-6 bg-secondary-bg rounded px-6 py-8">
        <h1 class="font-bold text-3xl text-primary-text">《React 学习手册》2017版读书笔记</h1>
        <div class="flex flex-wrap flex-row items-center mt-2 text-tertiary-text">
    <div class="mr-6 my-2">
        <i class="fas fa-calendar mr-1"></i>
        <span>2021-12-18</span>
    </div>
    <div class="mr-6 my-2">
        <i class="fas fa-clock mr-1"></i>
        <span>9分钟阅读时长</span>
    </div>
    
    
    <div class="mr-6 my-2">
        <i class="fas fa-folder mr-1"></i>
        
        <a href="/categories/%E6%8A%80%E6%9C%AF/" class="hover:text-eureka">技术</a>
        
    </div>
    

    
</div>
        
        
        

        <div class="content">
            <h2 id="javascript-函数式编程">Javascript 函数式编程</h2>
<h3 id="命令式与声明式">命令式与声明式</h3>
<p>命令式编程的特点是，其代码重点关注的是达成目标的具体过程。</p>
<pre><code class="language-js">var string = 'hello world';
var urlFriendly = '';

for (var i = 0; i &lt; string.length; i++) {
  if (string[i] === '') {
    urlFriendly += '-';
  } else {
    urlFriendly += string[i]
  }
}

console.log(urlFriendly);
</code></pre>
<p><code>命令式编程风格需要辅以大量注释说明帮助用户理解它的具体用途</code></p>
<p>声明式编程有一个比较突出的特点，那就是对执行结果的描述远胜于执行过程。</p>
<pre><code class="language-js">const string = 'hello world';
const urlFriendly = string.replace(/\s/g, '-');

console.log(urlFriendly);
</code></pre>
<p><code>使用string.replace方法是一种说明可能会发生什么的方式：字符串中的空格将会被替换。如何处理空格的细节被抽象封装到了replace函数内部</code></p>
<p>在一个声明式的程序中，语法本身描述了将会发生什么，相关的执行细节被隐藏了</p>
<p>本质上来说，使用声明式编程编写的应用程序更容易解释具体用途，当一个应用易于解释具体用途时，该应用也更易于进行功能扩展。</p>
<h3 id="函数式编程基本概念">函数式编程基本概念</h3>
<p>核心概念：不可变性、纯函数、数据转换、高阶函数、递归</p>
<h4 id="不可变性">不可变性</h4>
<p>不可变性就是指不可改变，在函数式编程中，数据是不可变的，它们永远无法修改</p>
<pre><code class="language-js">let color_lawn = {
  title: 'lawn',
  color: 'green'
  rating: 0,
}

var rateColor = function(color, rating) {
  return Object.assign({}, color, {rating: rating});
}

console.log(rateColor(color_lawn, 5).rating);  // 5
console.log(color_lawn.rating);  // 0
</code></pre>
<ul>
<li>Array.concat 会将数组串联起来，并将它添加到原生数组的副本上</li>
<li>Object.assign 会将对象的属性添加到原生对象的副本上</li>
<li>扩展运算符（&hellip;）有同样的效果</li>
</ul>
<h4 id="纯函数">纯函数</h4>
<p>纯函数是指，对于相同的输入，必定会得到相同的输出，而且不会有任何副作用、不修改全局变量，纯函数至少需要接收一个参数并且总是返回一个值或者其它函数</p>
<p>编写纯函数三原则：</p>
<ul>
<li>函数应该至少接收一个参数</li>
<li>函数应该总是返回一个值或者其它函数</li>
<li>函数不应该修改或影响任何传入的参数</li>
</ul>
<h4 id="数据转换">数据转换</h4>
<p>当需要从一个数组中移除某个元素时，我们倾向于使用 <code>Array.filter</code> 方法替代 <code>Array.pop</code> 或 <code>Array.splice</code> 方法，因为 <code>Array.filter</code> 方法是不可变的。</p>
<p>两个必须熟练掌握的函数：</p>
<ul>
<li><code>Array.map</code></li>
<li><code>Array.reduce</code></li>
</ul>
<p>它们是任何函数式程序员的主要武器，从其它数据源创建一个新的数据集的能力是程序员的必备技能。</p>
<p><code>Array.reduce</code> 方法的几种用法示例(通过 copillot 生成)：</p>
<pre><code class="language-js">// 使用 Array.reduce 求最大值
var numbers = [1, 2, 3, 4, 5];
var max = numbers.reduce(function(max, number) {
  return Math.max(max, number);
}, -Infinity);
</code></pre>
<pre><code class="language-js">// 使用 Array.reduce 求和
var numbers = [1, 2, 3, 4, 5];
var sum = numbers.reduce(function(sum, number) {
  return sum + number;
}, 0);
</code></pre>
<pre><code class="language-js">// 使用 Array.reduce 求组合
var numbers = [1, 2, 3, 4, 5];
var combinations = numbers.reduce(function(combinations, number) {
  return combinations.concat(
    combinations.map(function(combination) {
      return combination.concat(number);
    })
  );
}, [[]]);
</code></pre>
<pre><code class="language-js">// 使用 Array.reduce 将数组转换为对象
var numbers = [{ name: 'a1', vlaue: 1 }, { name: 'a2', value: 2 }];
var object = numbers.reduce(function(object, number) {
  return Object.assign({}, object, { [number.name]: number.value });
}, {});
</code></pre>
<pre><code class="language-js">// 使用 Array.reduce 将数组去重
var numbers = [1, 2, 3, 4, 5, 1, 2, 3, 4, 5];
var unique = numbers.reduce(function(unique, number) {
  if (unique.indexOf(number) === -1) {
    unique.push(number);
  }
  return unique;
}, []);
</code></pre>
<h4 id="高阶函数">高阶函数</h4>
<ul>
<li>函数作为参数传递</li>
<li>函数作为返回值返回</li>
</ul>
<p><code>Array.map</code>、<code>Array.filter</code>、<code>Array.reduce</code> 等方法都是高阶函数，它们接收一个函数作为参数</p>
<p><code>Currying(柯里化)</code> 是一种将某个操作中已经完成的结果保留，直到其余部分后续也完成后可以一并提供的机制。</p>
<pre><code class="language-js">const userLogs = userName =&gt; message =&gt; {
  console.log(`${userName}: ${message}`);
};
const log = userLogs('John');

log('Hello'); // John: Hello
log('World'); // John: World
</code></pre>
<h4 id="递归">递归</h4>
<p>递归是用户创建的函数调用自身的一种技术，一般来说，在解决实际问题涉及到循环时，递归函数可以提供一种替代性方案。</p>
<pre><code class="language-js">const countdown = (n, fn) =&gt; {
  if (n &lt;= 0) {
    fn();
  } else {
    countdown(n - 1, fn);
  }
}
</code></pre>
<h4 id="合成">合成</h4>
<p>链式调用是合成技术的一种</p>
<p>合成的目标是：通过整合若干简单函数构造一个更高阶的函数</p>
<h4 id="总结">总结</h4>
<p>三个简单的规则</p>
<ul>
<li>保持数据的不可变性</li>
<li>确保尽量使用纯函数，只接收一个参数，返回数据或其它函数</li>
<li>尽量使用递归处理循环</li>
</ul>
<h2 id="react">React</h2>
<p>虚拟DOM是由React元素组成的，概念上和HTML类似，不过它们实际上是JavaScript对象，直接访问JavaScript对象比访问DOM API高效的多。</p>
<p>浏览器的DOM是由DOM元素构成的，同样React的DOM是由React元素构成的，一个Reaact元素是对实际DOM元素应该如何表示的具体描述。</p>
<p>一个React元素只是一个JavaScript语法，用来告知React如何构造一个DOM元素。</p>
<p>两种创建React元素的方式：</p>
<ul>
<li>React.createElement(type, props, children)</li>
<li>React.createFactory(type) / React.DOM.type</li>
</ul>
<p>React元素 <code>&lt;h1 id=&quot;recipe-0&quot; data-type=&quot;title&quot;&gt;Baked Salmon&lt;/h1&gt;</code> 实际创建的内容</p>
<pre><code class="language-js">{
  $$typeof: Symbol(react.element),
  type: 'h1',
  key: null,
  ref: null,
  props: {
    id: 'recipe-0',
    'data-type': 'title',
    children: 'Baked Salmon'
  },
  _owner: null,
  _store: {}
}
</code></pre>
<p>三种创建React组件的方式</p>
<ul>
<li>React.createClass（将废弃）</li>
<li>React.Component</li>
<li>无状态函数式组件</li>
</ul>
<h3 id="无状态函数式组件">无状态函数式组件</h3>
<p>它们是简单的纯函数，所以我们应该在项目开发中尽可能地使用它们。</p>
<p>React开发团队承诺使用它们之后能够在某些方向提高性能，Facebook暗示将来无状态函数式组件将会比类组件更加高效。</p>
<h2 id="react与jsx">React与JSX</h2>
<p><code>React.createElement(IngredientList, { list: [...] })</code></p>
<p>vs</p>
<p><code>&lt;IngredientList list={[...]}&gt;</code></p>
<h3 id="jsx使用注意事项">jsx使用注意事项</h3>
<ul>
<li>支持组件嵌套</li>
<li>calssName替代class</li>
<li>JavaScript表达式用花括号包裹</li>
<li>支持求值计算</li>
<li>JSX数组映射</li>
</ul>
<h3 id="babel">Babel</h3>
<p>Babel的主要功能是转译，它的第一版程序叫6to5，是一款可以将 ES6 转换成 ES5 的工具。该项目于2015年2月正式更名为Babel</p>
<p>Babel presets 模块</p>
<pre><code>备注：以年命名的preset已经不再推荐使用，建议使用@babel/preset-env
</code></pre>
<ul>
<li>babel-preset-es2015 将ES2015、ES6转换成ES5</li>
<li>babel-preset-es2016 将ES2016转换成ES5</li>
<li>babel-preset-es2017 将ES2017转换成ES5</li>
<li>babel-preset-env 包含前面三个preset，并且支持最新的ES语法</li>
<li>babel-preset-react 将React转换成ES5</li>
<li>babel-preset-stage-0 实验性提议</li>
<li>babel-preset-stage-1 建议</li>
<li>babel-preset-stage-2 草稿</li>
<li>babel-preset-stage-3 候选</li>
</ul>
<h3 id="webpack">Webpack</h3>
<p>一个可以兼容多种不同类型文件的模块绑定器，并且可以将它们转换成单个文件，两个主要优点是模块化和网络性能。</p>
<p>模块化：用户可以将源代码分解成易于使用的部分或模块，特别是对于团队开发来说非常有用。</p>
<p>网络性能：在浏览器中只需载入依赖即可，即bundle，每个脚本标签都会创建http请求，并且每个http请求都会有延迟。将所有依赖项打包成单个文件后，只需发送一次http请求，就能加载所有必须的资源，从而避免了额外的网络延迟。</p>
<p>webpack可以处理的任务</p>
<ul>
<li>代码转译</li>
<li>代码拆分</li>
<li>代码压缩</li>
<li>特性标记</li>
<li>热替换(HMR)</li>
</ul>
<p>使用webpack模块打包工具的好处</p>
<ul>
<li>模块化</li>
<li>合成</li>
<li>效率</li>
<li>一致性</li>
</ul>
<h2 id="props-和-state">Props 和 State</h2>
<p>ECMAScript提案中提供了 Class Fields &amp; Static Properties 的支持，类的静态属性允许用户在类的内部声明中封装 propTypes 和 defaultProps。</p>
<p>大部分情况下，用户将会希望避免根据属性初始化state变量，因为在使用React组件时，用户希望限制包含state的组件的数量。</p>
<h2 id="组件扩展">组件扩展</h2>
<p>我们可以将任意JavaScript库与React集成，生命周期函数是其它JavaScript库进入，React库离开的地方，不过我们应该竭力避免添加管理UI的脚本库，这是React的工作。</p>
<p>高阶组件是一种极佳的功能复用方式，并且能够将组件State和生命周期管理的细节封装起来，它允许用户构建更多无状态函数式组件，以便可以一心一意的管理UI。</p>
<p>在React之外管理State意味着很多不同的事情，用户可以把React和Backbone模型搭配使用，或者其它任意MVC库的模型State，用户可以创建专属于自己的State管理系统，甚至可以使用全局变量，本地存储和Javascript纯文本管理State。在React之外管理State，简单的理解就是不在应用程序中使用React的State或者setState方法。</p>
<h3 id="flux">Flux</h3>
<p>Flux是Facebook开发的一种设计模式，旨在保持数据单向流动，在Flux诞生之前，Web开发架构由多种MVC设计模式的变体所主导，Flux是MVC的替代品，是一种完全不同的设计模式，并且与函数编程范式相辅相成。</p>
<p>Flux为我们提供一种Web应用架构，可以把它视为React的有益补充，具体来说，Flux提供了一种方法可以为React创建UI将要用的数据提供支持。</p>
<p>在Flux中应用程序的State数据是存放在React组件外部的Store进行管理的，Store保留或者修改数据，是唯一可以更新Flux视图的办法。</p>
<h2 id="redux">Redux</h2>
<p>Redux是类Flux的脚本库，但它不完全是Flux，它包含Action、Action生成器、Store，以及用于修改State的Action对象。</p>
<p>Redux通过移除Dixpatcher，对Flux的概念进行了一些简化，并使用单个不可变对象表示应用程序的State，Redux还引入了Reducer，它并不是Flux模式中的内容，Reducer是纯函数，它会根据当前的State和Action来返回一个新的State。</p>
<h3 id="state">State</h3>
<p>在纯React或者Flux应用中，比较推荐的做法是将State尽量存放在少数几个对象中，在Redux中，这是一条规则。</p>
<p>在构建Redux应用时，用户首先需要考虑的事情就是State树，尝试在单个对象中定义State，使用一些占位符数据草拟一个State树的JSON示例是一个非常好的习惯。</p>
<h3 id="action">Action</h3>
<p>Action是更新Redux应用程序State的唯一方式，Action为我们提供了应该变更哪些内容的指令。</p>
<p>使用一个Javascript常量来代替字符串，Javascript变量中的拼写错误将会导致浏览器抛出异常，将Action定义为常量也使得用户能够充分利用IDE工具的智能提示和代码自动补全功能。常量的使用并不是必需的，但是采用这种编码习惯也不失为一个好主意。</p>
<h3 id="reducer">Reducer</h3>
<p>Reducer是一个纯函数，它接受当前的State和Action，并返回一个新的State。</p>
<h3 id="store">Store</h3>
<p>Store是Redux应用程序中保存和管理State的地方，也是通过Store分发ction的形式，唯一的修改State数据的方式。Store会将应用程序的State作为单个对象进行保存。State的变更是通过Reducer来完成的。Store的创建是通过提供一个Reducer和可选的初始State来完成的。</p>
<h3 id="action-生成器">Action 生成器</h3>
<p>Action对象是通过简单的Javascript语法表示的，Action生成器就是返回这类语法格式的函数。</p>
<h3 id="中间件">中间件</h3>
<p>Redux中间件扮演了Store分发管理的角色，在Redux中，中间件是在分发某个Action过程中一系列顺序执行的若干函数构成。</p>
<h2 id="react-redux">React-Redux</h2>
<p>属性在组件树中向上和向下传递的过程增加了程序的复杂性，类似Redux这样的库就是为了缓解这一问题而诞生的，为了替代通过双向函数绑定实现组件树上的数据传递，我们可以直接从子组件分发Action来达到更新应用程序的目的。</p>
<h2 id="结语">结语</h2>
<p>React开发的关键是在正确的时间选择正确的工具。用户工具箱中已经拥有大量可以构建健壮应用程序的工具。现在只要按需取用即可。如果用户的应用程序没有涉及大量的数据，那么不必使用Redux。React和State是一个非常适合普通规模应用程序的解决方案。用户的应用程序也许并不需要用到服务器端渲染。不用急于集成它们，直到用户的应用程序人机交互频繁，并且包含大量移动流量时再添加这些特性也不晚。</p>

        </div>
        
        
        


        
        
        
        
<div class="flex flex-col md:flex-row md:justify-between -mx-2 mt-4 px-2 pt-4 border-t">
    <div>
        
        <span class="block font-bold">上一页</span>
        <a href="/posts/2022/01-26-tauri-app/" class="block">使用 Tauri&#43;React&#43;Tailwind 打造一款简单的Mac工具</a>
        
    </div>
    <div class="md:text-right mt-4 md:mt-0">
        
        <span class="block font-bold">下一页</span>
        <a href="/posts/2021/12/04/synology-spk/" class="block">群晖折腾手记六：添加第三方套件源</a>
        
    </div>
</div>

        



    </div>
    
    <div class="col-span-2">
        
        
        <div class="sticky top-16 z-10 hidden lg:block px-6 py-4  bg-primary-bg ">
    <span class="text-lg font-semibold">本页内容</span>
</div>
<div class="sticky-toc hidden lg:block px-6 pb-6 ">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#javascript-函数式编程">Javascript 函数式编程</a>
      <ul>
        <li><a href="#命令式与声明式">命令式与声明式</a></li>
        <li><a href="#函数式编程基本概念">函数式编程基本概念</a>
          <ul>
            <li><a href="#不可变性">不可变性</a></li>
            <li><a href="#纯函数">纯函数</a></li>
            <li><a href="#数据转换">数据转换</a></li>
            <li><a href="#高阶函数">高阶函数</a></li>
            <li><a href="#递归">递归</a></li>
            <li><a href="#合成">合成</a></li>
            <li><a href="#总结">总结</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#react">React</a>
      <ul>
        <li><a href="#无状态函数式组件">无状态函数式组件</a></li>
      </ul>
    </li>
    <li><a href="#react与jsx">React与JSX</a>
      <ul>
        <li><a href="#jsx使用注意事项">jsx使用注意事项</a></li>
        <li><a href="#babel">Babel</a></li>
        <li><a href="#webpack">Webpack</a></li>
      </ul>
    </li>
    <li><a href="#props-和-state">Props 和 State</a></li>
    <li><a href="#组件扩展">组件扩展</a>
      <ul>
        <li><a href="#flux">Flux</a></li>
      </ul>
    </li>
    <li><a href="#redux">Redux</a>
      <ul>
        <li><a href="#state">State</a></li>
        <li><a href="#action">Action</a></li>
        <li><a href="#reducer">Reducer</a></li>
        <li><a href="#store">Store</a></li>
        <li><a href="#action-生成器">Action 生成器</a></li>
        <li><a href="#中间件">中间件</a></li>
      </ul>
    </li>
    <li><a href="#react-redux">React-Redux</a></li>
    <li><a href="#结语">结语</a></li>
  </ul>
</nav>
</div>
<script>
    window.addEventListener('DOMContentLoaded', () => {
        enableStickyToc();
    });
</script>
        
    </div>
    

    
    
</div>
<script>
    document.addEventListener('DOMContentLoaded', ()=>{
        hljs.initHighlightingOnLoad();
    })
</script>

      </div>
    </div>
    
  </main>
  <footer class="pl-scrollbar">
    <div class="w-full max-w-screen-xl mx-auto"><div class="text-center p-6 pin-b">
    <p class="text-sm text-tertiary-text">Copyright (c) 2021. All rights reserved. &middot;  Powered by the <a href="https://github.com/wangchucheng/hugo-eureka" class="hover:text-eureka">Eureka</a> theme for <a href="https://gohugo.io" class="hover:text-eureka">Hugo</a></p>
</div></div>
  </footer>
</body>

</html>